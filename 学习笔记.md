# 学习笔记

[TOC]

## 任务概要

1. 了解一下目前统计CFS调度延迟的代码
2. 熟悉了之后再考虑如何在统计RT（实时调度器）的调度延迟

备注：

​	CFS调度的关键：update_stats_enqueue_sleeper  [fair.c]

​	统计的关键：sched_statistics

目前在CFS上的状态已经很完善完备了，因此要将其迁移到RT上

## 文件统计表

| 文件名              | 用途 | 备注 |
| ------------------- | ---- | ---- |
| auto_group.c        |      |      |
| auto_group.h        |      |      |
| boost.c             |      |      |
| clock.c             |      |      |
| completion.c        |      |      |
| core.c              |      |      |
| core_ctl.c          |      |      |
| cpuacct.c           |      |      |
| cpuacct.h           |      |      |
| cpudeadline.c       |      |      |
| cpudeadline.h       |      |      |
| cpufreq.c           |      |      |
| cpufreq_sched.c     |      |      |
| cpufreq_schedutil.c |      |      |
| cpupri.c            |      |      |
| cpupri.h            |      |      |
| cputime.c           |      |      |
| deadline.c          |      |      |
| debug.c             |      |      |
| energy.c            |      |      |
| fair.c              |      |      |
| features.h          |      |      |
| idle.c              |      |      |
| idle_task.c         |      |      |
| loadavg.c           |      |      |
| Makefile            |      |      |
| rt.c                |      |      |
| sched.h             |      |      |
| sched_avg.c         |      |      |
| stats.c             |      |      |
| stats.h             |      |      |
| stop_task.c         |      |      |
| swait.c             |      |      |
| tune.c              |      |      |
| tune.h              |      |      |
| wait.c              |      |      |
| walt.c              |      |      |
| walt.h              |      |      |

## 资料笔记

### 概念

Completely Fair Scheduler CFS：完全公平调度

cfs_rq：cfs的run queue

CFS的出发点：进程调度的效果应如同系统具备一个理想中的完美多任务处理器

CFS调度算法的核心：选择具有最小vruntime的任务

RR：Round Robin

### 实时调度策略

SCHED_FIFO实时调度策略，先到先服务

SCHED_RR实时调度策略，时间片轮转

SCHED_FIFO和SCHED_RR的不同：

| SCHED_FIFO                                                   | SCHED_RR                                               |
| ------------------------------------------------------------ | ------------------------------------------------------ |
| 一旦占用CPU则一直运行，直到有更高优先级的进程到达或自己放弃（阻塞或释放） | 进程在耗尽事先分配好它的时间后就不能再继续执行         |
|                                                              | 对于相同优先级的实时进程，RR可以让每个任务执行一段时间 |



### Linux调度的实现

#### 时间记账

1. 调度器实体结构：

```c++
struct sched_entity {
	/* For load-balancing: */
	struct load_weight		load;
	unsigned long			runnable_weight;
	struct rb_node			run_node;
	struct list_head		group_node;
	unsigned int			on_rq;

	u64				exec_start;
	u64				sum_exec_runtime;
	u64				vruntime;
	u64				prev_sum_exec_runtime;

	u64				nr_migrations;

	struct sched_statistics		statistics;
	...
};
```

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched.h?h=v5.2.1

2. 虚拟实时：

```c++
static void update_curr(struct cfs_rq *cfs_rq)
```

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/fair.c?h=v5.2.1

#### 进程选择

1. 挑选下一个任务：

```c++
static struct sched_entity *__pick_next_entity(struct sched_entity *se)
{
	struct rb_node *next = rb_next(&se->run_node);

	if (!next)
		return NULL;

	return rb_entry(next, struct sched_entity, run_node);
}
```

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/fair.c?h=v5.2.1

2. 向树中加入进程

```c++
// 更新运行时间和其它统计数据
static void enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
// 将数据项插入到红黑树中
static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)
```

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/fair.c?h=v5.2.1

3. 从树中删除进程

```c++
static void dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
```

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/fair.c?h=v5.2.1

#### 调度器入口

```c++
static void __sched notrace __schedule(bool preempt)

static inline struct task_struct *
pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
```

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/core.c?h=v5.2.1

​	调用schedule()：完成一些必要的检查, 并设置进程状态, 处理进程所在的就绪队列

​	调用pick_next_task()：
​	以优先级为序，从高到低，依次检查每一个调度类，如果当前cpu上所有的进程都是cfs调度的普通非实时进程, 则直接用cfs调度, 如果无程序可调度则调度idle进程，否则从优先级最高的调度器类sched_class_highest(目前是stop_sched_class)开始依次遍历所有调度器类的pick_next_task函数, 选择最优的那个进程执行

​	context_switch完成进程上下文切换

- 调用switch_mm()：把虚拟内存从一个进程映射切换到新进程中

- 调用switch_to()：从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息


#### 睡眠和唤醒

```sequence
Note left of TASK_RUNNING:任务是可运行的 
TASK_RUNNING->TASK_INTERRUPTIBLE:_add_wait_queue()将任务加到等待队列中
TASK_RUNNING->TASK_INTERRUPTIBLE:调用schedule()→调用deactivate_task()从运行队列中删除任务
Note right of TASK_INTERRUPTIBLE:任务是不可运行的
TASK_INTERRUPTIBLE->TASK_INTERRUPTIBLE:任务等待事件发生
TASK_INTERRUPTIBLE->TASK_RUNNING:try_to_wake_up()改变任务状态
TASK_INTERRUPTIBLE->TASK_RUNNING:调用activate_task()将任务加到运行队列
TASK_INTERRUPTIBLE->TASK_RUNNING:调用schedule()→__remove_wait_queue()从等待队列删除任务

```

### task_struct解释

#### 进程状态

```c++
volatile long state
```

##### 5个互斥状态

| 状态                 | 简称 | 描述                                                         |
| -------------------- | ---- | ------------------------------------------------------------ |
| TASK_RUNNING         | R    | 表示进程要么正在执行，要么正要准备执行（已经就绪），正在等待cpu时间片的调度 |
| TASK_INTERRUPTIBLE   | S    | 进程因为等待一些条件而被挂起（阻塞）而所处的状态。这些条件主要包括：硬中断、资源、一些信号……，一旦等待的条件成立，进程就会从该状态（阻塞）迅速转化成为就绪状态TASK_RUNNING |
| TASK_UNINTERRUPTIBLE | D    | 意义与TASK_INTERRUPTIBLE类似，除了不能通过接受一个信号来唤醒以外，对于处于TASK_UNINTERRUPIBLE状态的进程，哪怕我们传递一个信号或者有一个外部中断都不能唤醒他们。 |
| TASK_STOPPED         | T    | 进程被停止执行，当进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后就会进入该状态 |
| TASK_TRACED          | T    | 表示进程被debugger等进程监视，进程执行被调试程序所停止，当一个进程被另外的进程所监视，每一个信号都会让进城进入该状态 |

##### 2个终止状态

| 状态        | 简称 | 描述                                                         |
| ----------- | ---- | ------------------------------------------------------------ |
| EXIT_ZOMBIE | Z    | 进程的执行被终止，但是其父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程成为僵尸进程 |
| EXIT_DEAD   | X    | 进程的最终状态                                               |

### 进程内核栈

#### 内核栈与线程描述符

对每个进程，Linux内核都把两个不同的数据结构紧凑的存放在一个单独为进程分配的内存区域中

- 一个是内核态的进程堆栈，

- 另一个是紧挨着进程描述符的小数据结构thread_info，叫做线程描述符。

![thread_info](https://img-blog.csdn.net/20160512131035840)

#### 表示进程亲属关系的成员

| 字段         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| real_parent  | 指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程 |
| parent       | 指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与real_parent相同 |
| children     | 表示链表的头部，链表中的所有元素都是它的子进程               |
| sibling      | 用于把当前进程插入到兄弟链表中                               |
| group_leader | 指向其所在进程组的领头进程                                   |

### 进程调度

#### 优先级

![åæ ¸çä¼åçº§è¡¨ç¤º](https://img-blog.csdn.net/20160711101652744)

```c++
int prio, static_prio, normal_prio;
unsigned int rt_priority;
```

| 字段        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| static_prio | 用于保存静态优先级，是进程启动时分配的优先级，可以通过nice和sched_setscheduler系统调用来进行修改，否则在进程运行期间会一直保持恒定 |
| rt_priority | 用于保存实时优先级, 实时进程的优先级用实时优先级rt_priority来表示 |
| normal_prio | 表示基于进程的静态优先级static_prio和调度策略计算出的优先级. 因此即使普通进程和实时进程具有相同的静态优先级, 其普通优先级也是不同的, 进程分叉(fork)时, 子进程会继承父进程的普通优先级 |
| prio        | 保存进程的动态优先级                                         |

实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139）。值越大静态优先级越低。

```c++
#define MAX_USER_RT_PRIO    100
#define MAX_RT_PRIO     MAX_USER_RT_PRIO
#define MAX_PRIO        (MAX_RT_PRIO + 40)
#define DEFAULT_PRIO        (MAX_RT_PRIO + 20)
```

| 属性             | 数值 |
| ---------------- | ---- |
| MAX_USER_RT_PRIO | 100  |
| MAX_RT_PRIO      | 100  |
| MAX_PRIO         | 140  |
| DEFAULT_PRIO     | 120  |

| 进程类型             | 实时优先级rt_priority | 静态优先级static_prio | 普通优先级normal_prio     | 动态优先级prio |
| -------------------- | --------------------- | --------------------- | ------------------------- | -------------- |
| EDF调度的实时进程    | rt_priority           | 不使用                | MAX_DL_PRIO-1             | 维持原prio不变 |
| RT算法调度的实时进程 | rt_priority           | 不使用                | MAX_RT_PRIO-1-rt_priority | 维持原prio不变 |
| 普通进程             | 不使用                | static_prio           | static_prio               | static_prio    |
| 优先级提高的普通进程 | 不使用                | static_prio(改变)     | static_prio               | 维持原prio不变 |

#### 调度策略

```c++
unsigned int policy;

const struct sched_class *sched_class;
struct sched_entity se;
struct sched_rt_entity rt;

cpumask_t cpus_allowed;
```

| 字段         | 描述                                           |
| ------------ | ---------------------------------------------- |
| policy       | 调度策略                                       |
| sched_class  | 调度类                                         |
| se           | 普通进程的调用实体，每个进程都有其中之一的实体 |
| rt           | 实时进程的调用实体，每个进程都有其中之一的实体 |
| cpus_allowed | 用于控制进程可以在哪里处理器上运行             |

调度策略主要有以下五种：

```c++
/*
* Scheduling policies
*/
#define SCHED_NORMAL            0
#define SCHED_FIFO              1
#define SCHED_RR                2
#define SCHED_BATCH             3
/* SCHED_ISO: reserved but not implemented yet */
#define SCHED_IDLE              5
#define SCHED_DEADLINE          6
```

| 字段           | 描述                                                         | 所在调度器类 |
| -------------- | ------------------------------------------------------------ | ------------ |
| SCHED_NORMAL   | （也叫SCHED_OTHER）用于普通进程，通过CFS调度器实现。SCHED_BATCH用于非交互的处理器消耗型进程。SCHED_IDLE是在系统负载很低时使用 | CFS          |
| SCHED_BATCH    | SCHED_NORMAL普通进程策略的分化版本。采用分时策略，根据动态优先级(可用nice()API设置），分配 CPU 运算资源。注意：这类进程比上述两类实时进程优先级低，换言之，在有实时进程存在时，实时进程优先调度。但针对吞吐量优化 | CFS          |
| SCHED_IDLE     | 优先级最低，在系统空闲时才跑这类进程(如利用闲散计算机资源跑地外文明搜索，蛋白质结构分析等任务，是此调度策略的适用者） | CFS-IDLE     |
| SCHED_FIFO     | 先入先出调度算法（实时调度策略），相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务 | RT           |
| SCHED_RR       | 轮流调度算法（实时调度策略），后 者提供 Roound-Robin 语义，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。不同要求的实时任务可以根据需要用sched_setscheduler()API 设置策略 | RT           |
| SCHED_DEADLINE | 新支持的实时进程调度策略，针对突发型计算，且对延迟和完成时间高度敏感的任务适用。基于Earliest Deadline First (EDF) 调度算法 | DL           |

#### 调度类

```c++
extern const struct sched_class stop_sched_class;
extern const struct sched_class rt_sched_class;
extern const struct sched_class fair_sched_class;
extern const struct sched_class idle_sched_class;
```

| 调度器类         | 描述                                                         | 对应调度策略              |
| ---------------- | ------------------------------------------------------------ | ------------------------- |
| stop_sched_class | 优先级最高的线程，会中断所有其他线程，且不会被其他任务打断。作用：1.发生在cpu_stop_cpu_callback 进行cpu之间任务migration；2.HOTPLUG_CPU的情况下关闭任务。 | 无, 不需要调度普通进程    |
| dl_sched_class   | 采用EDF最早截至时间优先算法调度实时进程                      | SCHED_DEADLINE            |
| rt_sched_class   | RT，作用：实时线程                                           | SCHED_FIFO, SCHED_RR      |
| fair_sched_class | CFS（公平），作用：一般常规线程                              | SCHED_NORMAL, SCHED_BATCH |
| idle_sched_class | 每个cup的第一个pid=0线程：swapper，是一个静态线程。调度类属于：idel_sched_class，所以在ps里面是看不到的。一般运行在开机过程和cpu异常的时候做dump | SCHED_IDLE                |

进程优先级：

stop_sched_class -> dl_sched_class -> rt_sched_class -> fair_sched_class -> idle_sched_class

#### 调度实体

| 调度实体        | 名称             | 描述                                           | 对应调度器类     |
| --------------- | ---------------- | ---------------------------------------------- | ---------------- |
| sched_dl_entity | DEADLINE调度实体 | 采用EDF算法调度的实时调度实体                  | dl_sched_class   |
| sched_rt_entity | RT调度实体       | 采用Roound-Robin或者FIFO算法调度的实时调度实体 | rt_sched_class   |
| sched_entity    | CFS调度实体      | 采用CFS算法调度的普通非实时进程的调度实体      | fair_sched_class |

#### 进程调度制品的关系

| 调度器类         | 调度策略                  | 调度策略对应的调度算法                       | 调度实体        | 调度实体对应的调度对象                                       |
| ---------------- | ------------------------- | -------------------------------------------- | --------------- | ------------------------------------------------------------ |
| stop_sched_class | 无                        | 无                                           | 无              | 特殊情况, 发生在cpu_stop_cpu_callback 进行cpu之间任务迁移migration或者HOTPLUG_CPU的情况下关闭任务 |
| dl_sched_class   | SCHED_DEADLINE            | Earliest-Deadline-First最早截至时间有限算法  | sched_dl_entity | 采用DEF最早截至时间有限算法调度实时进程                      |
| rt_sched_class   | SCHED_RR  SCHED_FIFO      | Roound-Robin时间片轮转算法  FIFO先进先出算法 | sched_rt_entity | 采用Roound-Robin或者FIFO算法调度的实时调度实体               |
| fair_sched_class | SCHED_NORMAL  SCHED_BATCH | CFS完全公平懂调度算法                        | sched_entity    | 采用CFS算法普通非实时进程                                    |
| idle_sched_class | SCHED_IDLE                | 无                                           | 无              | 特殊进程, 用于cpu空闲时调度空闲进程idle                      |

![è°åº¦å¨çç»æ](https://img-blog.csdn.net/20160711101627235)

#### 调度时机

进程会进入调度器进行选择的条件：

进程处于TASK_RUNNING状态，并且

- 调用cond_resched()时
- 显式调用schedule()时
- 从系统调用或者异常中断返回用户空间时
- 从中断上下文返回用户空间时
- 在系统调用或者异常中断上下文中调用preempt_enable()时(多次调用preempt_enable()时，系统只会在最后一次调用时会调度)
- 在中断上下文中，从中断处理函数返回到可抢占的上下文时(这里是中断下半部，中断上半部实际上会关中断，而新的中断只会被登记，由于上半部处理很快，上半部处理完成后才会执行新的中断信号，这样就形成了中断可重入)

系统并不是每时每刻都允许调度的发生，当处于硬中断期间的时候，调度是被系统禁止的，之后硬中断过后才重新允许调度

#### 抢占时机

抢占可分为内核抢占和用户抢占

用户抢占发生的时机：

- 从系统调用返回用户空间
- 从中断(异常)处理程序返回用户空间

内核抢占发生的时机：

- 当从中断处理程序正在执行，且返回内核空间之前。当一个中断处理例程退出，在返回到内核态时(kernel-space)。这是隐式的调用schedule()函数，当前任务没有主动放弃CPU使用权，而是被剥夺了CPU使用权。

- 当内核代码再一次具有可抢占性的时候，如解锁（spin_unlock_bh）及使能软中断(local_bh_enable)等, 此时当kernel code从不可抢占状态变为可抢占状态时(preemptible again)。也就是preempt_count从正整数变为0时。这也是隐式的调用schedule()函数

- 如果内核中的任务显式的调用schedule(), 任务主动放弃CPU使用权

- 如果内核中的任务阻塞(这同样也会导致调用schedule()), 导致需要调用schedule()函数。任务主动放弃CPU使用权


## 参考资料

| 标题                                               | 网址                                                   | 备注                                                      |
| -------------------------------------------------- | ------------------------------------------------------ | --------------------------------------------------------- |
| Linux源码                                          | https://elixir.bootlin.com/linux/v5.2.1/source         | 无敌好用，可以快速搜索各种类型的定义                      |
| Linux内核分析——第四章 进程调度                     | https://www.cnblogs.com/20135235my/p/5398066.html      | 书《Linux内核设计与实现》的笔记总结，比较全面             |
| linux进程调度方法(SCHED_OTHER,SCHED_FIFO,SCHED_RR) | https://blog.csdn.net/maray/article/details/2900689    | 详细地介绍了NORMAL, FIFO, RR三种调度方式的异同点          |
| Linux进程管理与调度-之-目录导航                    | https://blog.csdn.net/gatieme/article/details/51456569 | 无敌全面深入细致的讲解Linux进程的文章                     |
| Linux进程的管理与调度（十五）                      | https://blog.csdn.net/gatieme/article/details/51699889 | 上面系列中，这一篇对进程调度讲解的很好，尤为重要          |
| Linux进程的管理与调度（十七）                      | https://blog.csdn.net/gatieme/article/details/51702662 | 这一篇有进程调度的数据结构讲解，详细解释了task_struct等类 |
|                                                    |                                                        |                                                           |
|                                                    |                                                        |                                                           |
|                                                    |                                                        |                                                           |
|                                                    |                                                        |                                                           |

## 编外资料

### 进程ID（pid）

内核中进程ID的类型pid_type

```c++
enum pid_type
{
	PIDTYPE_PID,
	PIDTYPE_TGID,
	PIDTYPE_PGID,
	PIDTYPE_SID,
};
```

- **PID**：内核唯一区分每个进程的标识

  pid是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值 

- **TGID**：线程组（轻量级进程组）的ID标识

  处于相同的线程组中的所有进程都有相同的TGID，但是由于他们是不同的进程，因此其pid各不相同；线程组组长（也叫主线程）的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。 

- **PGID**：进程组的ID标识

  独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作。例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。

- **SID**

  几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID,保存在task_struct的session成员中

#### PID命名空间

![å½åç©ºé´çå±æ¬¡å³ç³»å¾](https://img-blog.csdn.net/20160512133916444)

PS：父命名空间是知道子命名空间的存在，因此子命名空间要映射到父命名空间中去，因此上图中 level 1 中两个子命名空间的六个进程分别映射到其父命名空间的PID 号5~10

#### pid与upid

PID的管理围绕两个数据结构展开：

- struct pid是内核对PID的内部表示
- struct upid则表示特定的命名空间中可见的信息

```c++
struct pid  
{  
        atomic_t count;  
        /* 使用该pid的进程的列表， lists of tasks that use this pid  */
        struct hlist_head tasks[PIDTYPE_MAX];  
        int level;  
        struct upid numbers[1];  
};
count	是指使用该PID的task的数目；
level	表示可以看到该PID的命名空间的数目，也就是包含该进程的命名空间的深度
tasks[PIDTYPE_MAX]	是一个数组，每个数组项都是一个散列表头,分别对应以下三种类型：PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID
numbers[1]	一个upid的实例数组，每个数组项代表一个命名空间，用来表示一个PID可以属于不同的命名空间，该元素放在末尾，可以向数组添加附加的项。

struct upid
{  
    /* Try to keep pid_chain in the same cacheline as nr for find_vpid */
        int nr;  
        struct pid_namespace *ns;  
        struct hlist_node pid_chain;  
};  
nr	表示ID具体的值
ns	指向命名空间的指针
pid_chain	指向PID哈希列表的指针，用于关联对于的PID
```

### 三种线程概念

内核线程、轻量级线程、用户线程

