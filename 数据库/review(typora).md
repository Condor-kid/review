[TOC]

# 第一章 引言

### 1.1
数据库管理系统(DataBase-Management System, DBMS)

​	主要目标：提供一种**方便、高效地**存取数据库信息的途径

文件处理系统中存储组织信息的主要弊端：
- 数据的冗余和不一致
- 数据访问困难
- 数据孤立
- 完整性问题
- 原子性问题
- 并发访问异常
- 安全性问题

### 1.3 数据视图
#### 1.3.1 数据抽象
- 物理层

  最低层次的抽象，描述数据是怎样存储的

- 逻辑层

  逻辑层用户不必知道物理层结构，保证了*物理数据独立性*

- 视图层

![](assets/markdown-img-paste-20181219212355466.png)
#### 1.3.2 实例和模式
**实例(instance)**：特定时刻数据库中的信息集合

**模式(schema)**：数据库的总体设计（不频繁发生改变）

**物理模式**：在物理层描述数据库的设计

**逻辑模式**：在逻辑层描述数据库的设计

#### 1.3.3 数据模型
**数据模型**：数据库结构的基础
- **关系模型**

  用表的集合来表示数据和数据间的关系

- **实体-联系模型(E-R)**

  现实世界由一组称作实体的基本对象以及这些对象间的联系构成

- 基于对象的数据模型

- 半结构化数据模型

### 1.4 数据库语言

数据定义语言(Data-Definition Language)：定义数据库模式

数据操纵语言(Data-Manipulation Language)：表达数据库的查询和更新

#### 1.4.1 数据操纵语言(DML) <span id="1.4.1"></span> [返回](#2.5)

- 过程化DML：要求用户指定需要什么数据以及如何获得这些数据
- 声明式DML（非过程化DML）：只要求用户指定需要什么数据

**查询(query)**：对信息进行检索的语句
#### 1.4.2 数据定义语言(DDL)
数据库中的数据值必须满足某些**一致性约束**
- 域约束

  每个属性都有值域

- 参照完整性

  一个关系中属性集上的取值也在另一关系的某一属性集的取值中出现

- 断言

  数据库需要时刻满足的某一条件

- 授权

  对用户加以区别（读权限、插入权限、更新权限、删除权限）

DDL的输出放在**数据字典**中，数据字典包含了**元数据**，元数据是关于数据的数据

### 1.5 关系数据库

#### 1.5.1 表

![dapartment表](assets/markdown-img-paste-20181220162109137.png)
#### 1.5.2 数据操纵语言(DML)

![](assets/markdown-img-paste-20181220162221487.png)
#### 1.5.3 数据定义语言(DDL)

![](assets/markdown-img-paste-20181220162250538.png)

### 1.6 数据库设计

数据库设计的主要内容是数据库模式的设计
#### 1.6.1 设计过程
1. 制定出用户需求的规格文档
2. 概念设计阶段，将需求转换为数据库的概念模式
3. 逻辑设计阶段
4. 物理设计阶段
#### 1.6.3 实体-联系模型(E-R模型)
实体通过**属性**集合来描述

**联系**是几个实体之间的关联

**实体集、联系集**：同一类型所有 *实体/联系* 的集合
![](assets/markdown-img-paste-20181220163452123.png)

#### 1.6.4 规范化
目标：

​	1、没有不必要的冗余

​	2、能轻易地检索数据

使用**函数依赖**设计**范式**

### 1.7 数据存储和查询
数据库系统的功能部件可分为 *存储管理器* 和 *查询处理部件*
#### 1.7.1 存储管理器
存储管理部件包括：
- 权限及完整性管理器
- 事务管理器
- 文件管理器
- 缓冲区管理器

数据结构：
- 数据文件：存储数据库本身
- 数据字典：存储关于数据库结构的元数据（数据库模式）
- 索引：提供对数据项的快速访问

#### 1.7.2 查询处理器
查询处理器组件包括：
- DDL解释器：解释DDL语句并将定义记录在数据字典中
- DML编译器：将查询语言翻译为一个执行方案
- 查询执行引擎：执行由DML编译器产生的低级指令

### 1.8 事务
**事务**是数据库应用中完成单一逻辑功能的操作集合

其具有*原子性*、*一致性*、*持久性*

**恢复管理器**保证数据库系统的原子性和持久性

**并发控制管理器**控制并发事务间的相互影响，保证数据库的一致性

**事务管理器**包括并发控制管理器和恢复管理器

### 1.12 数据库用户和管理员
#### 1.12.1 数据库用户
数据库系统的用户可以分为四种不同类型：
- 无经验的用户
- 应用程序员
- 老练的用户
- 专门的用户
#### 1.12.2 数据库管理员
数据库管理员(DataBase Administrator, DBA)的作用包括：
- 模式定义
- 存储结构及存取方法定义
- 模式及物理组织的修改
- 数据访问授权
- 日常维护

### 1.14 总结
见书本P18



# 第二章 关系模型介绍

### 2.1 关系数据库的结构
关系数据库由**表**的结合构成

**关系** 用来指代表，**元组** 用来指代行，**属性** 用来指代表中的列

![](assets/markdown-img-paste-20181220171743522.png)

**关系实例**表示一个关系的特定的实例，即所包含的一组特定的行

**域**：关系中的属性允许取值的集合

若域中元素被看作是不可再分的单元，则域是**原子的**

**空值(null)**：一个特殊的值，表示值未知或不存在

### 2.2 数据库模式

**数据库模式**是数据库的逻辑设计

**数据库实例**是特定时刻数据库中数据的一个快照

**关系模式**对应与程序设计中的类型定义

![](assets/markdown-img-paste-20181220173439947.png)

department关系的模式：![](assets/markdown-img-paste-20181220173406633.png)

### 2.3 码

**超码**：一个或多个属性的集合，可以使我们在一个关系中唯一地标识一个元组

**候选码**：最小的超码

**主码**：被设计者选中用来在一个关系中区分不同元组的***候选码***

r$_1$在属性中包括r$_2$的主码，这个属性在r$_1$上被称作参照r$_2$的**外码**

关系r$_1$称为外码依赖的**参照关系**，关系r$_2$称作外码的**被参照关系**

**参照完整性约束**：要求参照关系的元组在特定属性上的取值等于被参照关系中某个元组在该属性上的取值

### 2.4 模式图 

![1545316872178](assets/1545316872178.png)

### 2.5 关系查询语言

**查询语言**：请求获取数据库信息的语言

*过程化语言、非过程化语言* [见1.4.1](#1.4.1) <span id="2.5"></span>

### 2.6 关系运算

**自然连接**：两个关系上所匹配的元组在两个关系共有的所有属性上取值*相同*

*笛卡尔积*运算从两个关系中合并元组，结果包含两个关系元组的*所有对*，不论属性值是否匹配

第6章将详细介绍关系代数，因此此处不再概述

### 2.7 总结

见P28



# 第三章 SQL

### 3.1 SQL查询语言概览

SQL语言有以下几个部分：

- 数据定义语言(DDL)：定义关系模式、删除关系、修改关系模式
- 数据操纵语言(DML)：从数据库中查询信息、在数据库中插入元组、删除元组、修改元组
- 完整性：完整性约束
- 视图定义
- 事务控制
- 嵌入式SQL和动态SQL
- 授权： DDL可以定义对关系和视图的访问权限

### 3.2 SQL数据定义

#### 3.2.2 基本模式定义

**create table**命令的通用形式：

![1545442650314](assets/1545442650314.png)

**create table**命令的例子：

![1545442695074](assets/1545442695074.png)

三个基本的完整性约束：

- primary key$(A_1,A_2, \cdots )$：属性 $(A_1,A_2, \cdots )$ 构成关系的主码
- foreign key$(B_1,B_2, \cdots )$ references s：属性 $(B_1,B_2, \cdots )$ 上的取值必须对应于关系s中某元组在主码属性上的取值
- not null：该属性上不允许空值

#### 3.3 SQL查询的基本结构

**自然连接**运算作用于两个关系，并产生一个关系作为结果。自然连接只考虑哪些在两个关系模式中都出现的属性上取值相同的元组对。

```mysql
select name,course_id
from instructor natural join teachers;
```

### 3.4 附加的基本运算

#### 3.4.1 更名运算

```mysql
select distinct T.name
from instructor as T, instrctor as S
where T.salary > S. salary and S.dept_name = 'Biology';
```

这种用**as**实现的重命名，被称作**表别名**或者是**相关名称**

#### 3.4.2 字符串运算

```mysql
select dept_name
from department
where building like '% Watson%'; 
-- 找出任意所在建筑名称中包含子串'Watson'的所有系名
```

字符串使用**like**操作符来实现模式匹配。用两个特殊字符来描述模式：

- **百分号(%)**：匹配任意字串
- **下划线(_)**：匹配任意一个字符

### 3.5 集合运算

**union, intersect, except**运算分别对应于集合论中的$\cup(并) \cap(交), -(差)$运算

![1545449042727](assets/1545449042727.png)

### 3.6 空值

空值给关系运算带来了特殊的问题，包括算数运算、比较运算和集合运算

- 算术运算

  如果算数表达式任一输入为空，则该算数表达式结果为空

- 比较运算

  1 < null = unknown

- 布尔运算

  | 运算符  | true R unknown | false R unknown | unknown R unknown |
  | ------- | -------------- | --------------- | ----------------- |
  | **and** | unknown        | false           | unknown           |
  | **or**  | true           | unknown         | unknown           |

  **not unknown** = unknown

### 3.7 聚集函数

**聚集函数**是以值的一个集合为输入、返回单个值的函数

常见聚集函数：avg, min, max, sum, count

#### 3.7.2 分组聚集

```mysql
select dept_name, avg(salary) as avg_salary
from instructor
group by dept_name;
-- 找出每个系的平均工资
```

查询结果：![1545447069605](assets/1545447069605.png)

出现在**select**语句中但没有被聚集的属性只能是出现在**group by**子句中的那些属性

#### 3.7.3 having子句

**having**子句中的谓词在形成分组后才起作用
```mysql
select dept_name, avg(salary) as avg_salary
from instructor
group by dept_name
having avg(salary) > 42000
-- 找出每个平均工资大于42000的系
```

### 3.8 嵌套子查询

子查询是嵌套在另一个查询中的**select-from-where**表达式。

#### 3.8.1 集合成员资格

连接词**in/not in**测试元组是否是集合中的成员

![1545448773747](assets/1545448773747.png)

#### 3.8.2 集合的比较

集合的比较需要用到比较运算符以及**some/all**关键词

![1545448862776](assets/1545448862776.png)

![1545448871749](assets/1545448871749.png)

#### 3.8.3 空关系测试

**exists**结构在作为参数的子查询非空时返回**true**值

![1545449001105](assets/1545449001105.png)

#### 3.8.5 from子句中的子查询

任何**select-from-where**表达式返回的结果都是关系，因而可以被插入到另一个**select-from-where**中任何关系可以出现的位置

![1545449237372](assets/1545449237372.png)

#### 3.8.6 with子句

**with**子句提供定义临时关系的方法，这个定义只对包含**with**子句的查询有效

![1545449857703](assets/1545449857703.png)

### 3.9 数据库的修改

#### 3.9.1 删除

```mysql
delete from r
where P;
```

#### 3.9.2 插入

```mysql
insert into course
values('CS-437','C++','CS',4)
```

#### 3.9.3 更新

```mysql
update instructor
set salary = salary * 1.05;
```

### 3.10 总结

见P57



# 第4章 中级SQL

### 4.1 连接表达式

#### 4.1.2 外连接

外连接的三种形式：

1. **左外连接(left outer join)**：只保留出现在左边的关系中的元组
2. **右外连接(right outer join)**：只保留出现在右边的关系中的元组
3. **全外连接(full outer join)**：保留出现在两个关系中的元组

![1545531196257](assets/1545531196257.png)

**on**和**where**在外连接中的表现是不同的，**on**条件是外连接声明的一部分，但**where**子句却不是

### 4.2 视图

**视图**：不是逻辑模型的一部分，但作为虚拟关系对用户可见

#### 4.2.1 视图定义

**create view**命令的格式为：

```mysql
create view v as <query expression>;
-- <query expression> 可以是任何合法的查询表达式，v表示视图名
```

#### 4.2.2 SQL查询中使用视图

在查询中，视图名可以出现在关系名可以出现的任何地方。

![1545531651455](assets/1545531651455.png)

#### 4.2.3 物化视图

**物化视图**：如果用于定义视图的实际关系改变，视图也跟着修改

保持物化视图一直在最新状态的过程称为*物化视图维护*或*视图维护*

#### 4.2.4 视图更新

一个视图是**可更新的**，如果其满足以下条件：

- from子句中只有一个数据库关系
- select子句只包含关系的属性名，不包含表达式、聚集或distinct声明
- 任何没有出现在select子句中的属性都没有not null约束，同时也不是主码的一部分
- 查询中不含有group by或having子句

![1545532311552](assets/1545532311552.png)

### 4.3 事务

**事务**由查询和更新语句的序列组成

事务结束标志：

- **Commit work**：提交当前事务
- **Rollback work**：回滚当前事务

### 4.4 完整性约束

#### 4.4.2 not null 约束

**not null**声明禁止在该属性上插入空值

#### 4.4.3 unique 约束

`unique(A1,A2, ... ,Am)`

unique声明指出属性A1,A2,…Am形成了一个候选码

#### 4.4.4 check 子句

**check(P)**子句指定一个谓词P，关系中的每个元组都必须满足谓词P

```mysql
create table department
( dept_name varchar (20),
budget int,
check (budget>0));
```

#### 4.4.5 参照完整性

**参照完整性**：保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现

#### 4.4.7 断言

一个**断言**就是一个谓词，它表达了我们希望数据库总能满足的一个条件

断言为如下形式：`create assertion <assertion-name> check <predicate>;`

### 4.5 SQL的数据类型与模式

#### 4.5.2 默认值

SQL允许为属性指定默认值

![1545534259604](assets/1545534259604.png)

#### 4.5.3 创建索引

**索引**：创建在关系的属性上，允许数据库高效地找到关系中那些在属性上取给定值的元组，而不用扫描关系中的所有元组

创建索引示例：`create index studentID_index on student(ID);`

### 4.6 授权

对数据的授权包括：

- 授权读取数据
- 授权插入新数据
- 授权更新数据
- 授权删除数据

每种类型的授权都称为一个**权限**

SQL包括select, insert, update, delete权限

grant语句用来授予权限，revoke语句用来收回权限

### 4.7 总结

见P85



# 第五章 高级SQL

### 5.3 触发器

**触发器**是一条语句，当对数据库做修改时，它自动被系统执行

设置触发器机制的要求：

- 指明什么条件下执行触发器
  - 一个引起触发器被检测的事件
  - 一个触发器执行必须满足的条件
- 指明触发器执行的动作



# 第六章 形式化关系查询语言

### 6.1 关系代数

关系代数是一种*过程化*查询语言

关系代数的基本运算有：*选择、投影、并、集合差、笛卡尔积、更名*

其它运算：*集合交、自然连接、赋值*

#### 6.1.1 基本运算

一元运算：*选择、投影、更名*

二元运算：*并、集合差、笛卡尔积*

##### 6.1.1.1 选择运算

**选择($\sigma$)**运算选出满足给定谓词的元组

通常，我们允许在选择谓词中进行比较，使用的是：$=, \neq, <, \leq, >, \geq$

另外可以用连词$and(\and), or(\or), not(\neg)$将多个谓词合并为一个较大的谓词

![1545537368858](assets/1545537368858.png)

##### 6.1.1.2 投影运算

**投影($\Pi$)**运算返回作为参数的关系

![1545537578901](assets/1545537578901.png)

##### 6.1.1.3 关系运算的组合

由于关系代数运算的结果类型仍为关系，因此可以把多个关系代数运算组合成一个**关系代数表达式**

![1545537695662](assets/1545537695662.png)

##### 6.1.1.4 并运算

![1545537783797](assets/1545537783797.png)

要使**并**运算**$r \cup s$**有意义（*相容*），必须满足以下两个条件：

1. 关系r和s必须是同元的，即它们的属性数目必须相同
2. 对所有的i，r的第i个属性的域必须和s的第i个属性的域相同

##### 6.1.1.5 集合差运算

用$-$表示**集合差**运算表示在一个关系中而不在另一个关系中的那些元组

![1545538076649](assets/1545538076649.png)

集合差运算必须在*相容*的关系间进行（与并运算类似），即关系同元且属性的域相同

##### 6.1.1.6 笛卡尔积运算

**笛卡尔积($\times$)**运算可以将任意两个关系的信息组合在一起

![1545538546439](assets/1545538546439.png)

###### 6.1.1.7 更名运算

**更名($\rho$)**运算可以给关系赋予名字

![1545538797875](assets/1545538797875.png)



#### 6.1.3 附加的关系代数运算

##### 6.1.3.1 集合交运算

**集合交($\cap$)**运算：$r  \cap s = r - ( r - s )$

![1545539126055](assets/1545539126055.png)

##### 6.1.3.2 自然连接运算

r和s的**自然连接**表示为$r \Join s$

![1545540842131](assets/1545540842131.png)

##### 6.1.3.3 赋值运算

**赋值($\leftarrow$)**运算可以给临时关系变量赋值

$r \Join s​$可以表示为：![1545540983370](assets/1545540983370.png)

##### 6.1.3.4 外连接运算

**外连接**运算是连接运算的扩展，它在结果中创建带空值的元组，以此来保留在连接中丢失的那些元组

外连接运算有三种形式：

- 左外连接：$=\Join$ 

  取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性

- 右外连接：$\Join=$

  与左外连接相反

- 全外连接：$= \Join =$

  既做左外连接也做右外连接

